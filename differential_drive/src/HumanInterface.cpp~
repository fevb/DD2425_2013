 /*
 * Human Interface.cpp
 * --------------------
 * Copyright : (c) 2013, Germain Haessig <germain.haessig@ens-cachan.fr>
 * Licence   : BSD3
 * part of the differential_drive ROS package, for ROBOT13@KTH
 * 
 * Draw an interface, enable keyboard control
 */

#include "ros/ros.h"
#include <string.h>
#include <algorithm>

#include "differential_drive/KeyEvent.h"
#include "differential_drive/MouseEvent.h"
#include "differential_drive/Pose.h"
#include "differential_drive/Path.h"
#include "differential_drive/Carrot.h"

#include "differential_drive/Odometry.h"

#include <SDL/SDL.h>
#include <math.h>

using namespace differential_drive;
ros::Publisher key_pub;

ros::Subscriber pose_sub;
ros::Subscriber pose_target_sub;
ros::Subscriber path_sub;
ros::Subscriber carrot_sub;

#define WIDTH 400
#define HEIGHT 400
#define BPP 4
#define DEPTH 32

bool quit = false;
bool redraw = true;

float pose_x = 0;
float pose_y = 0;
float pose_theta = 0;

float pose_target_x = 0;
float pose_target_y = 0;
float pose_target_theta = 0;

std::vector<float> path_x;
std::vector<float> path_y;
std::vector<float> path_theta;
std::vector<float> path_cx;
std::vector<float> path_cy;

float carrot_x = 0;
float carrot_y = 0;

// Receive carrot
void receive_carrot(const Carrot::ConstPtr &msg)
{
	carrot_x = msg->x;
	carrot_y = msg->y;

	printf("Received new carrot position\n");
	redraw = true;
}

// Receive path
void receive_path(const Path::ConstPtr &msg)
{
	path_x.clear();
	path_y.clear();
	path_theta.clear();
	path_cx.clear();
	path_cy.clear();

	for (uint i = 0; i < msg->x.size(); ++i)
	{
		path_x.push_back(msg->x[i]);
		path_y.push_back(msg->y[i]);
		path_theta.push_back(msg->theta[i]);
		path_cx.push_back(msg->carrot_x[i]);
		path_cy.push_back(msg->carrot_y[i]);
	}
	printf("Received path with %u poses\n", msg->x.size());
	redraw = true;
}

// Receive pose estimate
void receive_pose_estimate(const differential_drive::Odometry& msg)
{
	pose_x = msg.x;
	pose_y = msg.y;
	pose_theta = msg.theta;
	redraw = true;
	printf("Estimated position is: (%.3fm, %.3fm) heading: %.1fdeg\n", pose_x, pose_y, pose_theta*180/M_PI);
}

// Receive pose target
void receive_pose_target(const Pose::ConstPtr &msg)
{
	pose_target_x = msg->x;
	pose_target_y = msg->y;
	pose_target_theta = msg->theta;
	redraw = true;
	printf("Target position is: (%.3fm, %.3fm) heading: %.1fdeg\n", pose_target_x, pose_target_y, pose_target_theta*180/M_PI);
}

void setpixel(SDL_Surface *screen, int x, int y, Uint8 r, Uint8 g, Uint8 b)
{
	// Check bounds
	if (x < 0 || x >= screen->w || y < 0 || y >= screen->h)
		return;

    Uint32 *pixmem32;
    Uint32 colour;

    colour = SDL_MapRGB( screen->format, r, g, b );

    pixmem32 = (Uint32*) screen->pixels  + y*screen->pitch/BPP + x;
    *pixmem32 = colour;
}

void setpixelunsafe(SDL_Surface *screen, int x, int y, Uint8 r, Uint8 g, Uint8 b)
{
    Uint32 *pixmem32;
    Uint32 colour;

    colour = SDL_MapRGB( screen->format, r, g, b );

    pixmem32 = (Uint32*) screen->pixels  + y + x;
    *pixmem32 = colour;
}

void draw_line(SDL_Surface *screen, int x0, int y0, int x1, int y1, Uint8 r, Uint8 g, Uint8 b)
{
	// Check for line with zero length
	if (x0 == x1 && y0 == y1)
	{
		setpixel(screen, x0, y0, r, g, b);
		return;
	}

	// Choose direction
	int dx = x1-x0;
	int dy = y1-y0;
	if (abs(dy) <= abs(dx))
	{
		if (x0 > x1)
		{
			std::swap(x0,x1);
			std::swap(y0,y1);
			dx = -dx;
			dy = -dy;
		}

		// Step in x-direction
		for (int x = x0; x <= x1; ++x)
		{
			int y = y0 + round( float((x-x0) * (y1-y0)) / dx );
			setpixel(screen, x, y, r, g, b);
		}
	}
	else
	{
		if (y0 > y1)
		{
			std::swap(x0,x1);
			std::swap(y0,y1);
			dx = -dx;
			dy = -dy;
		}

		// Step in x-direction
		for (int y = y0; y <= y1; ++y)
		{
			int x = x0 + round( float((y-y0) * (x1-x0)) / dy );
			setpixel(screen, x, y, r, g, b);
		}
	}
}

int m2x(SDL_Surface* screen, float x)
{
	return screen->w/2 + round(x*100);
}

int m2y(SDL_Surface* screen, float y)
{
	return screen->h/2 - round(y*100);
}

void draw_robot(SDL_Surface* screen, float x, float y, float theta, Uint8 r, Uint8 g, Uint8 b)
{
	float triangle_x[3] = {.2,-.1,-.1};
	float triangle_y[3] = {0,.1,-.1};
	float sx[3];
	float sy[3];

	// Calculate vertex positions
	float c = cos(theta);
	float s = sin(theta);
	for (int i = 0; i < 3; ++i)
	{
		float tx = c * triangle_x[i] + -s * triangle_y[i] + x;
		float ty = s * triangle_x[i] + c * triangle_y[i] + y;

		sx[i] = m2x(screen, tx); //screen->w/2 + round(tx*100);
		sy[i] = m2y(screen, ty); //screen->h/2 - round(ty*100);

	}

	// Draw the loop
	for (int i = 1; i < 3; ++i)
		draw_line(screen, sx[i-1], sy[i-1], sx[i], sy[i], r,g,b);
	draw_line(screen, sx[2], sy[2], sx[0], sy[0], r,g,b);

	// Point in center of robot
	//setpixel(screen, m2x(screen, x), m2y(screen, y), r,g,b);
}

void DrawScreen(SDL_Surface* screen)
{
    int x, y, ytimesw;

    if(SDL_MUSTLOCK(screen))
    {
        if(SDL_LockSurface(screen) < 0) return;
    }

    for(y = 0; y < screen->h; y++ )
    {
    	// Clear screen
    	ytimesw = y*screen->pitch/BPP;
        for( x = 0; x < screen->w; x++ )
            setpixelunsafe(screen, x, ytimesw, 0, 0, 0);
    }

    // Draw robot path
	for (uint i = 0; i < path_x.size(); ++i)
	{
		draw_line(screen,
			m2x(screen, path_x[i]),
			m2y(screen, path_y[i]),
			m2x(screen, path_cx[i]),
			m2y(screen, path_cy[i]),
			0,0,255);
	}

    // Draw target robot pose
    draw_robot(screen, pose_target_x, pose_target_y, pose_target_theta, 0,255,0);

    // Draw estimated robot pose
    draw_robot(screen, pose_x, pose_y, pose_theta, 0,0,255);

    // Draw carrot
    int rx[] = {0,5,0,-5,0};
    int ry[] = {5,0,-5,0,5};
    for (int i = 0; i < 4; ++i)
		draw_line(screen,
				m2x(screen, carrot_x) + rx[i],
				m2y(screen, carrot_y) + ry[i],
				m2x(screen, carrot_x) + rx[i+1],
				m2y(screen, carrot_y) + ry[i+1],
				255,127,0);

    if(SDL_MUSTLOCK(screen)) SDL_UnlockSurface(screen);

    SDL_Flip(screen);
}

int main(int argc, char **argv) {
	ros::init(argc, argv, "HumanInterface"); //Creates a node named "HumanInterface"
	ros::NodeHandle n;
	key_pub = n.advertise < KeyEvent > ("/human/keyboard", 100000);
	pose_sub = n.subscribe("odometry", 1000, receive_pose_estimate);
	pose_target_sub = n.subscribe("/motion/pose_target", 1000, receive_pose_target);
	path_sub = n.subscribe("/motion/path", 1000, receive_path);
	carrot_sub = n.subscribe("/motion/carrot", 1000, receive_carrot);

	SDL_Surface *screen;
	SDL_Event event;

	if (SDL_Init(SDL_INIT_VIDEO) < 0)
		return 1;

	if (!(screen = SDL_SetVideoMode(WIDTH, HEIGHT, DEPTH, SDL_HWSURFACE))) {
		SDL_Quit();
		printf("SDL_SetVideoMode failed to open window\n");
		return 1;
	}

	SDL_WM_SetCaption("HumanInterface", "HumanInterface");

	ros::Rate loop_rate(30); // frequency
	while (ros::ok() && !quit) {
		while (SDL_PollEvent(&event)) {
			switch (event.type) {
			case SDL_QUIT:
				quit = true;
				break;
			case SDL_KEYDOWN:
			case SDL_KEYUP:
			{
				printf("key '%s' %s\n", SDL_GetKeyName( event.key.keysym.sym ), event.type == SDL_KEYDOWN ? "PRESSED" : "RELEASED");
				// Send key event message
				timeval now;
				gettimeofday(&now, NULL);
				KeyEvent key;
				key.timestamp = now.tv_sec+double(now.tv_usec)/1000000.0;
				key.sym = event.key.keysym.sym;
				key.pressed = (event.type == SDL_KEYDOWN);
				key.name = SDL_GetKeyName( event.key.keysym.sym );
				key_pub.publish(key);
				break;
			}
			}
		}

		if (redraw) {
			DrawScreen(screen);
			redraw = false;
		}

		loop_rate.sleep(); // Sleep for 10 ms
		ros::spinOnce(); // Process ros messages
	}

	SDL_Quit();
	return EXIT_SUCCESS;
}

